/**
 * MatrixProtocolSystem - Sistema principal simplificado
 * 
 * Foca na funcionalidade essencial: execu√ß√£o real de Claude agents
 * com gerenciamento de rate limits otimizado para Claude Code Pro plan
 */

import { ParallelClaudeRunner, claudeRunner } from './core/ParallelClaudeRunner'
import { rateLimitHandler, createSprintTask } from './utils/OptimizedRateLimitHandler'
import * as fs from 'fs'
import * as path from 'path'
import chalk from 'chalk'

interface SystemConfiguration {
  enableMonitoring: boolean
  maxConcurrentAgents: number
  debugMode: boolean
}

interface AgentExecution {
  agentName: string
  taskType: string
  context: any
}

export class MatrixProtocolSystem {
  private claudeRunner: ParallelClaudeRunner
  private configuration: SystemConfiguration
  private isRunning: boolean = false
  private executionHistory: any[] = []

  constructor(config?: Partial<SystemConfiguration>) {
    this.configuration = {
      enableMonitoring: true,
      maxConcurrentAgents: 3,
      debugMode: process.env.NODE_ENV === 'development',
      ...config
    }

    this.claudeRunner = claudeRunner
  }

  /**
   * Verificar se sistema est√° em execu√ß√£o
   */
  get systemRunning(): boolean {
    return this.isRunning
  }

  /**
   * Valida√ß√£o do ambiente
   */
  private async validateEnvironment(): Promise<void> {
    console.log(chalk.blue('üîç Validando ambiente do sistema...'))
    
    const requiredAgents = [
      'alex-santos.md',
      'marina-costa.md', 
      'ricardo-lima.md',
      'camila-rodriguez.md',
      'bruno-oliveira.md'
    ]

    const agentsDir = path.join(__dirname, 'agents')
    
    // Verificar diret√≥rio de agents
    if (!fs.existsSync(agentsDir)) {
      throw new Error(`Diret√≥rio de agents n√£o encontrado: ${agentsDir}`)
    }

    // Verificar cada agent file
    for (const agentFile of requiredAgents) {
      const agentPath = path.join(agentsDir, agentFile)
      if (!fs.existsSync(agentPath)) {
        throw new Error(`Agent file n√£o encontrado: ${agentPath}`)
      }

      const content = fs.readFileSync(agentPath, 'utf-8')
      if (!content.trim()) {
        console.log(chalk.yellow(`‚ö†Ô∏è Agent file est√° vazio: ${agentPath}`))
      }
    }

    // Verificar disponibilidade do Claude CLI
    console.log(chalk.gray('üîß Verificando Claude CLI...'))
    const claudeAvailable = await ParallelClaudeRunner.checkCLIAvailable()
    if (!claudeAvailable) {
      console.log(chalk.yellow('‚ö†Ô∏è Claude CLI n√£o detectado. Sistema funcionar√° em modo simula√ß√£o.'))
    } else {
      console.log(chalk.green('‚úÖ Claude CLI detectado e dispon√≠vel'))
    }

    console.log(chalk.green('‚úÖ Valida√ß√£o do ambiente completada'))
  }

  /**
   * Iniciar sistema
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      console.log(chalk.yellow('‚ö†Ô∏è Sistema j√° est√° em execu√ß√£o'))
      return
    }

    try {
      await this.validateEnvironment()
      
      this.isRunning = true

      console.log(chalk.green('üöÄ Matrix Protocol System iniciado com sucesso'))

    } catch (error: any) {
      this.isRunning = false
      console.error(chalk.red('‚ùå Falha na inicializa√ß√£o do sistema:'), error.message)
      throw error
    }
  }

  /**
   * Parar sistema
   */
  async stop(): Promise<void> {
    if (!this.isRunning) {
      console.log(chalk.yellow('‚ö†Ô∏è Sistema n√£o est√° em execu√ß√£o'))
      return
    }

    try {
      console.log(chalk.blue('üõë Parando Matrix Protocol System...'))
      
      this.isRunning = false

      // Cleanup Claude runner
      await this.claudeRunner.cleanup()
      
      // Rate limit handler cleanup
      rateLimitHandler.cleanup()

      console.log(chalk.green('‚úÖ Sistema parado com sucesso'))

    } catch (error: any) {
      console.error(chalk.red('‚ùå Erro ao parar sistema:'), error.message)
    }
  }

  /**
   * Executar agent individual
   */
  async executeAgent(agentName: string, prompt: string, context?: any): Promise<any> {
    if (!this.isRunning) {
      throw new Error('Sistema n√£o est√° em execu√ß√£o')
    }

    console.log(chalk.blue(`ü§ñ Executando agent: ${agentName}`))
    
    try {
      const result = await this.claudeRunner.executeAgent(agentName, prompt, context)
      
      this.executionHistory.push({
        agentName,
        prompt: prompt.substring(0, 100) + '...',
        timestamp: new Date(),
        success: true,
        result: result.substring(0, 200) + '...'
      })

      console.log(chalk.green(`‚úÖ Agent ${agentName} executado com sucesso`))
      return result

    } catch (error: any) {
      this.executionHistory.push({
        agentName,
        prompt: prompt.substring(0, 100) + '...',
        timestamp: new Date(),
        success: false,
        error: error.message
      })

      console.error(chalk.red(`‚ùå Erro na execu√ß√£o do agent ${agentName}:`), error.message)
      throw error
    }
  }

  /**
   * Executar m√∫ltiplos agents em sequ√™ncia
   */
  async executeAgentSequence(executions: AgentExecution[]): Promise<any[]> {
    console.log(chalk.blue(`üìã Executando sequ√™ncia de ${executions.length} agents`))
    
    const results = []
    
    for (const execution of executions) {
      try {
        const prompt = this.buildPrompt(execution.agentName, execution.taskType, execution.context)
        const result = await this.executeAgent(execution.agentName, prompt, execution.context)
        results.push({ agentName: execution.agentName, result, success: true })
      } catch (error: any) {
        console.log(chalk.yellow(`‚ö†Ô∏è Continuando sequ√™ncia apesar do erro em ${execution.agentName}`))
        results.push({ agentName: execution.agentName, error: error.message, success: false })
      }
    }

    return results
  }

  /**
   * Construir prompt otimizado para agent e task type
   */
  private buildPrompt(agentName: string, taskType: string, context: any): string {
    const basePrompts = {
      'sprint-planning': `Como ${agentName}, conduza o sprint planning:
- Analise o backlog e estime esfor√ßo
- Defina metas claras do sprint
- Identifique depend√™ncias e riscos
- Distribua responsabilidades

Context: ${JSON.stringify(context, null, 2)}`,

      'daily': `Como ${agentName}, conduza a daily scrum:
- Reporte progresso desde √∫ltima reuni√£o
- Defina pr√≥ximos passos
- Identifique impedimentos
- Solicite colabora√ß√£o se necess√°rio

Context: ${JSON.stringify(context, null, 2)}`,

      'implementation': `Como ${agentName}, trabalhe na implementa√ß√£o:
- Desenvolva funcionalidades conforme especifica√ß√£o
- Mantenha qualidade e boas pr√°ticas
- Documente mudan√ßas importantes
- Execute testes relevantes

Context: ${JSON.stringify(context, null, 2)}`,

      'validation': `Como ${agentName}, execute valida√ß√£o:
- Teste funcionalidades implementadas
- Verifique crit√©rios de aceita√ß√£o
- Identifique bugs ou problemas
- Valide performance e usabilidade

Context: ${JSON.stringify(context, null, 2)}`,

      'retrospective': `Como ${agentName}, conduza a retrospectiva:
- Analise o que funcionou bem
- Identifique pontos de melhoria
- Proponha a√ß√µes para pr√≥ximo sprint
- Colete feedback da equipe

Context: ${JSON.stringify(context, null, 2)}`
    }

    return basePrompts[taskType as keyof typeof basePrompts] || 
           `Como ${agentName}, execute: ${taskType}. Context: ${JSON.stringify(context, null, 2)}`
  }

  /**
   * Executar demonstra√ß√£o completa do sistema
   */
  async runDemonstration(): Promise<void> {
    console.log(chalk.blue('üé≠ Iniciando demonstra√ß√£o do Matrix Protocol System'))
    
    const demonstrations = [
      {
        agentName: 'alex-santos',
        taskType: 'sprint-planning',
        context: {
          sprintGoal: 'Implementar dynamic navigation system',
          duration: '2 weeks',
          team: ['alex', 'marina', 'ricardo', 'camila', 'bruno']
        }
      },
      {
        agentName: 'marina-costa',
        taskType: 'implementation',
        context: {
          feature: 'Frontend navigation components',
          technology: 'Vue 3 + Nuxt'
        }
      },
      {
        agentName: 'ricardo-lima',
        taskType: 'implementation',
        context: {
          feature: 'Backend API endpoints',
          technology: 'Node.js + TypeScript'
        }
      },
      {
        agentName: 'camila-rodriguez',
        taskType: 'validation',
        context: {
          testTypes: ['unit', 'integration', 'e2e'],
          coverage: 'minimum 80%'
        }
      },
      {
        agentName: 'alex-santos',
        taskType: 'retrospective',
        context: {
          sprintCompleted: true,
          velocity: 'as planned'
        }
      }
    ]

    try {
      const results = await this.executeAgentSequence(demonstrations)
      
      console.log(chalk.green('‚úÖ Demonstra√ß√£o conclu√≠da com sucesso'))
      console.log(chalk.cyan(`üìä Resumo: ${results.filter(r => r.success).length}/${results.length} agents executados com sucesso`))

    } catch (error: any) {
      console.error(chalk.red('‚ùå Erro na demonstra√ß√£o:'), error.message)
      throw error
    }
  }

  /**
   * Mostrar status do sistema
   */
  displayStatus(): void {
    console.log(chalk.cyan('\nüìä Status do Matrix Protocol System'))
    console.log('=' .repeat(50))
    
    const rateLimitStatus = rateLimitHandler.getStatus()
    const claudeStatus = this.claudeRunner.getExecutionStatus()
    
    console.log(`üîã Rate Limit: ${rateLimitStatus.state.promptsRemaining} prompts restantes`)
    console.log(`‚ö° Claude Runner: ${claudeStatus.running} execu√ß√µes ativas`)
    console.log(`üìà Hist√≥rico: ${this.executionHistory.length} execu√ß√µes realizadas`)
    console.log(`üéØ Status: ${this.isRunning ? 'Ativo' : 'Inativo'}`)
    
    if (this.executionHistory.length > 0) {
      const successCount = this.executionHistory.filter(h => h.success).length
      const successRate = Math.round((successCount / this.executionHistory.length) * 100)
      console.log(`‚úÖ Taxa de sucesso: ${successRate}%`)
    }
    
    console.log('=' .repeat(50))
  }

  /**
   * Obter hist√≥rico de execu√ß√µes
   */
  getExecutionHistory(): any[] {
    return [...this.executionHistory]
  }
}

/**
 * CLI Handler para diferentes modos de execu√ß√£o
 */
async function main() {
  const mode = process.argv.find(arg => arg.startsWith('--mode='))?.split('=')[1] || 'interactive'
  const system = new MatrixProtocolSystem()

  // Graceful shutdown
  process.on('SIGINT', async () => {
    console.log(chalk.yellow('\nüõë Recebido SIGINT - finalizando sistema...'))
    await system.stop()
    process.exit(0)
  })

  process.on('SIGTERM', async () => {
    console.log(chalk.yellow('\nüõë Recebido SIGTERM - finalizando sistema...'))
    await system.stop()
    process.exit(0)
  })

  try {
    switch (mode) {
      case 'interactive':
        console.log(chalk.blue('üéØ Modo Interativo - Matrix Protocol System'))
        console.log(chalk.gray('Use Ctrl+C para sair'))
        
        await system.start()
        system.displayStatus()
        
        // Keep alive for interactive mode
        const keepAlive = () => setTimeout(keepAlive, 1000)
        keepAlive()
        break

      case 'demo':
        console.log(chalk.blue('üé≠ Modo Demonstra√ß√£o - Matrix Protocol System'))
        
        await system.start()
        await system.runDemonstration()
        system.displayStatus()
        await system.stop()
        break

      case 'monitoring':
        console.log(chalk.blue('üìä Modo Monitoramento - Matrix Protocol System'))
        
        await system.start()
        
        // Display status every 10 seconds
        const statusInterval = setInterval(() => {
          if (!system.systemRunning) {
            clearInterval(statusInterval)
            return
          }
          
          system.displayStatus()
        }, 10000)
        
        // Keep alive for monitoring mode
        const keepMonitoring = () => setTimeout(keepMonitoring, 1000)
        keepMonitoring()
        break

      case 'sprint':
        console.log(chalk.blue('üèÉ‚Äç‚ôÇÔ∏è Modo Sprint - Matrix Protocol System'))
        
        await system.start()
        
        // Execute sprint simulation
        const sprintTasks = [
          { agentName: 'alex-santos', taskType: 'sprint-planning', context: { goal: 'Sistema completo' } },
          { agentName: 'marina-costa', taskType: 'daily', context: { day: 1 } },
          { agentName: 'ricardo-lima', taskType: 'implementation', context: { feature: 'core-api' } },
          { agentName: 'camila-rodriguez', taskType: 'validation', context: { phase: 'integration' } },
          { agentName: 'alex-santos', taskType: 'retrospective', context: { sprint: 'completed' } }
        ]
        
        await system.executeAgentSequence(sprintTasks)
        system.displayStatus()
        await system.stop()
        break

      default:
        console.error(chalk.red(`‚ùå Modo desconhecido: ${mode}`))
        console.log(chalk.gray('Modos dispon√≠veis: interactive, demo, monitoring, sprint'))
        process.exit(1)
    }

  } catch (error: any) {
    console.error(chalk.red('‚ùå Erro fatal:'), error.message)
    
    if (system.systemRunning) {
      await system.stop()
    }
    
    process.exit(1)
  }
}

// Execute main se chamado diretamente
if (require.main === module) {
  main().catch(error => {
    console.error(chalk.red('‚ùå Erro n√£o tratado:'), error)
    process.exit(1)
  })
}