/**
 * TaskDelegator - Claude Code SDK Integration
 * 
 * Executa agents usando Claude Code SDK com tools nativos
 * Real execution com cria√ß√£o de arquivos via Read, Edit, Write tools
 */

import { query } from "@anthropic-ai/claude-code"
import * as fs from 'fs'
import * as path from 'path'

interface ExecutionInstruction {
  action: 'create_file' | 'edit_file' | 'read_file' | 'analyze_structure'
  path: string
  content?: string
  changes?: string
  description: string
  priority: 'high' | 'medium' | 'low'
}

interface SprintInstructions {
  sprintName: string
  phase: string
  agent: string
  context: string
  tasks: ExecutionInstruction[]
  expectedFiles: string[]
  completionCriteria: string[]
}

interface TaskExecution {
  id: string
  agentName: string
  prompt: string
  status: 'pending' | 'running' | 'completed' | 'failed'
  startTime?: Date
  endTime?: Date
  instructions?: SprintInstructions
  result?: string
  error?: string
}

interface TaskConfig {
  maxConcurrent: number
  timeout: number
  agentsDirectory: string
}

export class TaskDelegator {
  private executions: Map<string, TaskExecution> = new Map()
  private config: TaskConfig
  private isShuttingDown: boolean = false

  constructor(config?: Partial<TaskConfig>) {
    this.config = {
      maxConcurrent: 3,
      timeout: 600000, // 10 minutes for file operations
      agentsDirectory: './agents',
      ...config
    }
  }

  /**
   * Executar agent usando Claude Code SDK
   */
  async executeAgent(
    agentName: string, 
    prompt: string, 
    context: any = {}
  ): Promise<string> {
    const executionId = `${agentName}-${Date.now()}`
    
    // Criar execu√ß√£o
    const execution: TaskExecution = {
      id: executionId,
      agentName,
      prompt,
      status: 'pending',
      startTime: new Date()
    }
    
    this.executions.set(executionId, execution)
    
    try {
      execution.status = 'running'
      
      console.log(`üöÄ Executando ${agentName} via Claude Code SDK...`)
      
      // Carregar system prompt do agent
      const systemPrompt = await this.loadAgentSystemPrompt(agentName)
      
      // Construir prompt completo com contexto do projeto
      const fullPrompt = this.buildSprintPrompt(agentName, prompt, context)
      
      // EXECU√á√ÉO REAL via Claude Code SDK
      const result = await query({
        prompt: fullPrompt,
        options: {
          appendSystemPrompt: systemPrompt
        }
      })
      
      // Extrair texto do resultado Query
      const resultText = String(result)
      
      execution.status = 'completed'
      execution.endTime = new Date()
      execution.result = resultText
      
      console.log(`‚úÖ ${agentName} executado com sucesso via SDK`)
      console.log(`üìÑ Resultado: ${resultText.substring(0, 100)}...`)
      
      return resultText || 'Execu√ß√£o completada com sucesso'
      
    } catch (error: any) {
      execution.status = 'failed'
      execution.endTime = new Date()
      execution.error = error.message
      
      console.error(`‚ùå Erro na execu√ß√£o de ${agentName} via SDK:`, error)
      throw error
      
    }
  }

  /**
   * Carregar system prompt do agent
   */
  private async loadAgentSystemPrompt(agentName: string): Promise<string> {
    try {
      const agentPath = path.join('./agents', `${agentName}.md`)
      
      if (fs.existsSync(agentPath)) {
        const agentContent = fs.readFileSync(agentPath, 'utf-8')
        
        // Adicionar contexto espec√≠fico do Claude Code
        const claudeCodeContext = `
${agentContent}

## üõ†Ô∏è FERRAMENTAS DISPON√çVEIS
Voc√™ tem acesso aos seguintes tools nativos do Claude Code:
- **Read**: Para ler arquivos existentes e entender o contexto
- **Edit**: Para modificar arquivos existentes
- **Write**: Para criar novos arquivos
- **Glob**: Para encontrar arquivos por padr√£o

## üìç CONTEXTO DO PROJETO
- Projeto: Matrix Protocol Dynamic Navigation
- Localiza√ß√£o: /home/neto/projects/matrix-protocol/
- Tecnologias: Nuxt 3, Vue 3, TypeScript, @nuxt/content

## ‚ö° INSTRU√á√ïES IMPORTANTES
- SEMPRE use os tools nativos para criar/modificar arquivos
- Siga os padr√µes existentes do projeto
- Documente suas implementa√ß√µes
- Teste quando poss√≠vel
`
        
        return claudeCodeContext
      }
      
      // Fallback para prompt gen√©rico
      return this.getGenericAgentPrompt(agentName)
      
    } catch (error: any) {
      console.error(`‚ùå Erro ao carregar prompt do agent ${agentName}:`, error)
      return this.getGenericAgentPrompt(agentName)
    }
  }

  /**
   * Construir prompt espec√≠fico para sprint
   */
  private buildSprintPrompt(agentName: string, basePrompt: string, context: any): string {
    const sprintContext = this.getSprintContext(context)
    
    return `
# üéØ EXECU√á√ÉO DE SPRINT - MATRIX PROTOCOL

## üìã SPRINT ATUAL
${sprintContext}

## üéØ OBJETIVO ESPEC√çFICO
${basePrompt}

## üìÅ ESTRUTURA DO PROJETO
- **Root**: /home/neto/projects/matrix-protocol/
- **Website**: /home/neto/projects/matrix-protocol/website/
- **Docs**: /home/neto/projects/matrix-protocol/website/docs/dynamic-navigation/
- **Content**: /home/neto/projects/matrix-protocol/website/content/

## ‚ö° A√á√ïES NECESS√ÅRIAS
Como ${agentName}, execute as seguintes tarefas usando os tools Read, Edit, Write:

1. **Analise** a estrutura atual usando Read tool
2. **Implemente** as mudan√ßas necess√°rias usando Write/Edit tools
3. **Documente** o que foi criado/modificado
4. **Siga** os padr√µes existentes do projeto

## üéØ RESULTADO ESPERADO
Implementa√ß√£o funcional que atenda aos objetivos da sprint, com arquivos reais criados no projeto Matrix Protocol.

**IMPORTANTE**: Use sempre os tools nativos do Claude Code para modificar o projeto real.
`
  }

  /**
   * Obter contexto da sprint atual
   */
  private getSprintContext(context: any): string {
    if (context?.sprintName?.includes('3') || context?.sprintName?.includes('Migra√ß√£o')) {
      return `
**Sprint 3 - Migra√ß√£o Gradual e Integra√ß√£o**

**Objetivo**: Implementar sistema de feature flags para migra√ß√£o gradual da navega√ß√£o din√¢mica
**Entregas**:
- Sistema de feature flags (/website/utils/feature-flags.ts)
- Integra√ß√£o com navega√ß√£o existente
- A/B testing e rollback system
- Performance validation (Lighthouse ‚â• 90, navega√ß√£o ‚â§ 200ms)

**Stories Principais**:
- Story 3.1: Sistema de Feature Flags
- Story 3.2: Valida√ß√£o e Performance
`
    }
    
    return `
**Sprint Execution**
Execu√ß√£o de tarefas do Matrix Protocol Dynamic Navigation project.
`
  }

  /**
   * Prompt gen√©rico para agent
   */
  private getGenericAgentPrompt(agentName: string): string {
    const agentRoles = {
      'alex-santos': 'L√≠der T√©cnico & Arquiteto especializado em coordena√ß√£o e decis√µes arquiteturais',
      'marina-costa': 'Frontend Developer especializada em Vue 3, Nuxt e componentes de navega√ß√£o',
      'ricardo-lima': 'Nuxt/Content Specialist especializado em @nuxt/content e discovery APIs',
      'camila-rodriguez': 'QA Engineer especializada em valida√ß√£o e testes automatizados',
      'bruno-oliveira': 'Content Specialist especializado em estrutura de conte√∫do e i18n'
    }
    
    const role = agentRoles[agentName as keyof typeof agentRoles] || 'Especialista t√©cnico'
    
    return `
Voc√™ √© ${agentName}, ${role}.

## üõ†Ô∏è FERRAMENTAS DISPON√çVEIS
- **Read**: Para ler arquivos existentes
- **Edit**: Para modificar arquivos existentes  
- **Write**: Para criar novos arquivos
- **Glob**: Para encontrar arquivos por padr√£o

## üìç CONTEXTO
- Projeto: Matrix Protocol Dynamic Navigation
- Tecnologias: Nuxt 3, Vue 3, TypeScript
- Localiza√ß√£o: /home/neto/projects/matrix-protocol/

Execute as tarefas solicitadas usando os tools nativos do Claude Code.
`
  }

  /**
   * Extrair contexto da sprint do prompt
   */
  private extractSprintContext(prompt: string, context: any): {
    sprintName: string
    phase: string
    description: string
  } {
    
    // Detectar Sprint 3 no prompt ou contexto
    if (prompt.includes('migra√ß√£o') || prompt.includes('Migra√ß√£o') || context?.sprintName?.includes('3')) {
      return {
        sprintName: "Sprint 3 - Migra√ß√£o Gradual e Integra√ß√£o",
        phase: "Story 1 - Sistema de Feature Flags",
        description: "Implementar sistema de feature flags para migra√ß√£o gradual da navega√ß√£o din√¢mica"
      }
    }
    
    // Fallback gen√©rico
    return {
      sprintName: "Sprint 3 - Migra√ß√£o Gradual e Integra√ß√£o", 
      phase: "Implementa√ß√£o Geral",
      description: "Execu√ß√£o de tarefas da sprint de migra√ß√£o"
    }
  }

  /**
   * Gerar tasks espec√≠ficas baseadas no agent e contexto
   */
  private generateTasksFromPrompt(
    agentName: string, 
    prompt: string, 
    sprintContext: any
  ): ExecutionInstruction[] {
    
    // Tasks espec√≠ficas para Sprint 3 - alex-santos
    if (agentName === 'alex-santos' && sprintContext.sprintName.includes('Sprint 3')) {
      return [
        {
          action: 'analyze_structure',
          path: '/home/neto/projects/matrix-protocol/website/',
          description: 'Analisar estrutura atual do projeto para identificar pontos de integra√ß√£o',
          priority: 'high'
        },
        {
          action: 'create_file',
          path: '/home/neto/projects/matrix-protocol/website/utils/feature-flags.ts',
          content: this.generateFeatureFlagContent(),
          description: 'Criar sistema de feature flags para controle da navega√ß√£o din√¢mica',
          priority: 'high'
        },
        {
          action: 'read_file',
          path: '/home/neto/projects/matrix-protocol/website/composables/useDocsNavigation.ts',
          description: 'Verificar composable atual de navega√ß√£o para integra√ß√£o',
          priority: 'medium'
        },
        {
          action: 'edit_file',
          path: '/home/neto/projects/matrix-protocol/website/composables/useDocsNavigation.ts',
          changes: 'Integrar feature flag DYNAMIC_NAVIGATION e implementar fallback',
          description: 'Integrar feature flags no composable de navega√ß√£o existente',
          priority: 'high'
        }
      ]
    }
    
    // Tasks gen√©ricas para outros agents
    return [
      {
        action: 'analyze_structure',
        path: '/home/neto/projects/matrix-protocol/website/',
        description: `Analisar projeto para execu√ß√£o como ${agentName}`,
        priority: 'medium'
      }
    ]
  }

  /**
   * Gerar conte√∫do do sistema de feature flags
   */
  private generateFeatureFlagContent(): string {
    return `// Feature Flag System for Dynamic Navigation
// Generated by Matrix Protocol System - Sprint 3

interface FeatureFlags {
  DYNAMIC_NAVIGATION: boolean
  LEGACY_NAVIGATION: boolean
  A_B_TESTING: boolean
}

export class FeatureFlagManager {
  private flags: FeatureFlags = {
    DYNAMIC_NAVIGATION: false, // Start disabled for gradual migration
    LEGACY_NAVIGATION: true,   // Keep legacy as fallback
    A_B_TESTING: false        // Enable for testing phase
  }

  /**
   * Check if dynamic navigation is enabled
   */
  isDynamicNavigationEnabled(): boolean {
    return this.flags.DYNAMIC_NAVIGATION
  }

  /**
   * Toggle dynamic navigation (admin only)
   */
  toggleDynamicNavigation(enabled: boolean): void {
    this.flags.DYNAMIC_NAVIGATION = enabled
    this.flags.LEGACY_NAVIGATION = !enabled
  }

  /**
   * Enable A/B testing mode
   */
  enableABTesting(): void {
    this.flags.A_B_TESTING = true
  }

  /**
   * Get current flag status
   */
  getFlags(): FeatureFlags {
    return { ...this.flags }
  }
}

export const featureFlags = new FeatureFlagManager()
`
  }

  /**
   * Extrair arquivos esperados das tasks
   */
  private extractExpectedFiles(tasks: ExecutionInstruction[]): string[] {
    return tasks
      .filter(task => task.action === 'create_file' || task.action === 'edit_file')
      .map(task => task.path)
  }

  /**
   * Gerar crit√©rios de conclus√£o
   */
  private generateCompletionCriteria(sprintContext: any, tasks: ExecutionInstruction[]): string[] {
    const criteria = [
      'Todos os arquivos especificados foram criados/modificados',
      'C√≥digo segue padr√µes existentes do projeto',
      'Funcionalidade testada e funcionando'
    ]

    if (sprintContext.sprintName.includes('Sprint 3')) {
      criteria.push(
        'Sistema de feature flags implementado e funcional',
        'Integra√ß√£o com navega√ß√£o existente sem quebras',
        'Fallback para navega√ß√£o legacy configurado'
      )
    }

    return criteria
  }

  /**
   * Exibir instru√ß√µes formatadas para Claude executar
   */
  private displayInstructionsForClaude(instructions: SprintInstructions): void {
    console.log('\n' + '='.repeat(80))
    console.log(`üéØ INSTRU√á√ïES PARA CLAUDE EXECUTAR`)
    console.log('='.repeat(80))
    console.log(`üìã Sprint: ${instructions.sprintName}`)
    console.log(`‚ö° Fase: ${instructions.phase}`)
    console.log(`üë§ Agent: ${instructions.agent}`)
    console.log(`üìù Contexto: ${instructions.context}`)
    console.log('')
    
    console.log(`üìã TASKS A EXECUTAR (${instructions.tasks.length} total):`)
    instructions.tasks.forEach((task, index) => {
      const priorityIcon = task.priority === 'high' ? 'üî¥' : task.priority === 'medium' ? 'üü°' : 'üü¢'
      console.log(`${index + 1}. ${priorityIcon} ${task.action.toUpperCase()}: ${task.description}`)
      console.log(`   üìÅ Path: ${task.path}`)
      if (task.content) {
        console.log(`   üìù Conte√∫do: Ser√° criado novo arquivo`)
      }
      if (task.changes) {
        console.log(`   ‚úèÔ∏è Mudan√ßas: ${task.changes}`)
      }
      console.log('')
    })
    
    console.log(`üìÅ ARQUIVOS ESPERADOS (${instructions.expectedFiles.length} total):`)
    instructions.expectedFiles.forEach(file => {
      console.log(`   - ${file}`)
    })
    console.log('')
    
    console.log(`‚úÖ CRIT√âRIOS DE CONCLUS√ÉO:`)
    instructions.completionCriteria.forEach(criteria => {
      console.log(`   - ${criteria}`)
    })
    
    console.log('\n' + '='.repeat(80))
    console.log(`üöÄ CLAUDE: Execute as tasks acima usando Read, Edit, Write tools`)
    console.log('='.repeat(80))
  }

  /**
   * Construir prompt contextual com informa√ß√µes do projeto
   */
  private buildContextualPrompt(basePrompt: string, context: any): string {
    const projectContext = this.gatherProjectContext()
    const currentSprint = this.getCurrentSprintContext(context)
    
    return `
# üéØ CONTEXTO DO PROJETO MATRIX PROTOCOL

Voc√™ est√° executando uma sprint no projeto **Matrix Protocol Dynamic Navigation**.

## üìç LOCALIZA√á√ÉO E ESTRUTURA
- **Projeto root**: /home/neto/projects/matrix-protocol/
- **Working directory**: /home/neto/projects/matrix-protocol/.claude/
- **Website**: /home/neto/projects/matrix-protocol/website/
- **Docs**: /home/neto/projects/matrix-protocol/website/docs/dynamic-navigation/

## üéØ SPRINT ATUAL: ${currentSprint.name}
${currentSprint.context}

## üìä STATUS DO PROJETO
${projectContext}

## üõ†Ô∏è FERRAMENTAS DISPON√çVEIS NO CLAUDE CODE
Voc√™ tem acesso total aos seguintes tools nativos:

### üìñ **Read Tool**
- Ler qualquer arquivo do projeto
- Entender estrutura existente
- Analisar c√≥digo atual

### ‚úèÔ∏è **Edit Tool** 
- Modificar arquivos existentes
- Fazer mudan√ßas espec√≠ficas em c√≥digo
- Refatorar componentes

### üìù **Write Tool**
- Criar novos arquivos
- Implementar novos componentes
- Gerar documenta√ß√£o

### üîç **Glob Tool**
- Encontrar arquivos por padr√£o
- Mapear estrutura de diret√≥rios
- Localizar recursos espec√≠ficos

## üìã INSTRU√á√ïES DA SPRINT
${basePrompt}

## ‚ö° A√á√ïES NECESS√ÅRIAS
1. **SEMPRE** use Read tool primeiro para entender o contexto
2. **CRIE** arquivos reais usando Write tool 
3. **MODIFIQUE** arquivos existentes usando Edit tool
4. **DOCUMENTE** todas as mudan√ßas que fizer
5. **SIGA** os padr√µes existentes do projeto
6. **TESTE** suas implementa√ß√µes quando poss√≠vel

## üéØ RESULTADO ESPERADO
Produzir arquivos reais, funcionais e bem integrados ao projeto Matrix Protocol.
Todas as modifica√ß√µes devem seguir os padr√µes de qualidade estabelecidos.

---
**Inicie sempre lendo a estrutura atual com Read tool, depois implemente as mudan√ßas solicitadas.**
`
  }

  /**
   * Coletar contexto atual do projeto
   */
  private gatherProjectContext(): string {
    return `
### üìÅ ESTRUTURA DO PROJETO
- **Backend**: .claude/ (sistema de agents e execu√ß√£o)
- **Frontend**: website/ (Nuxt 3 application)
- **Docs**: website/docs/dynamic-navigation/ (documenta√ß√£o e sprints)
- **Content**: website/content/ (conte√∫do multil√≠ngue PT/EN)

### üèÉ SPRINTS EXECUTADAS
- ‚úÖ **Sprint 1**: Prepara√ß√£o e Padroniza√ß√£o (COMPLETED)
- ‚úÖ **Sprint 2**: API de Navega√ß√£o Din√¢mica (COMPLETED)
- üöÄ **Sprint 3**: Migra√ß√£o Gradual e Integra√ß√£o (EM EXECU√á√ÉO)

### üë• TEAM AGENTS
- **alex-santos**: L√≠der T√©cnico & Arquiteto
- **marina-costa**: Frontend Developer (Vue/Nuxt)
- **ricardo-lima**: Nuxt/Content Specialist
- **camila-rodriguez**: QA Engineer
- **bruno-oliveira**: Content Specialist

### üõ†Ô∏è STACK TECNOL√ìGICO
- **Framework**: Nuxt 3 + Vue 3 + TypeScript
- **Content**: @nuxt/content para documenta√ß√£o
- **UI**: Nuxt UI components
- **i18n**: Suporte multil√≠ngue PT/EN
`
  }

  /**
   * Obter contexto da sprint atual
   */
  private getCurrentSprintContext(context: any): { name: string; context: string } {
    // Detectar sprint baseado no contexto
    if (context?.sprintName) {
      return {
        name: context.sprintName,
        context: this.getSprintSpecificContext(context.sprintName)
      }
    }
    
    // Fallback para Sprint 3 (mais prov√°vel)
    return {
      name: "Sprint 3 - Migra√ß√£o Gradual e Integra√ß√£o",
      context: this.getSprintSpecificContext("Sprint 3")
    }
  }

  /**
   * Contexto espec√≠fico por sprint
   */
  private getSprintSpecificContext(sprintName: string): string {
    switch (sprintName) {
      case "Sprint 1":
        return `
**Foco**: Prepara√ß√£o e Padroniza√ß√£o do Content
**Objetivo**: Auditar e padronizar estrutura de conte√∫do para descoberta autom√°tica
**Entregas**: Scripts de auditoria, mapeamento de estrutura, cat√°logo de frontmatter
`
      case "Sprint 2":
        return `
**Foco**: Desenvolvimento da API de Navega√ß√£o Din√¢mica  
**Objetivo**: Criar sistema core de descoberta autom√°tica
**Entregas**: Composables, algoritmos de constru√ß√£o de √°rvore, cache de navega√ß√£o
`
      case "Sprint 3":
      default:
        return `
**Foco**: Migra√ß√£o Gradual e Integra√ß√£o
**Objetivo**: Implementar solu√ß√£o preservando estabilidade
**Entregas**: Sistema de feature flags, migra√ß√£o por A/B testing, valida√ß√£o de performance

### üéØ OBJETIVOS SPRINT 3
1. **Feature Flag System**: Implementar \`DYNAMIC_NAVIGATION\`
2. **A/B Testing**: Coexist√™ncia das duas vers√µes
3. **Performance**: Manter Lighthouse ‚â• 90, navega√ß√£o ‚â§ 200ms
4. **Rollback**: Sistema de volta instant√¢nea se necess√°rio

### üìã STORIES PRINCIPAIS
- **Story 3.1**: Migra√ß√£o por Feature Flag
- **Story 3.2**: Valida√ß√£o e Performance
`
    }
  }

  /**
   * Executar m√∫ltiplos agents em paralelo
   */
  async executeParallel(
    agentPrompts: Array<{ agentName: string; prompt: string; context?: any }>
  ): Promise<Array<{ agentName: string; result: string; error?: string }>> {
    console.log(`üîÑ Executando ${agentPrompts.length} agents via Task tool`)
    
    const promises = agentPrompts.map(async ({ agentName, prompt, context }) => {
      try {
        const result = await this.executeAgent(agentName, prompt, context)
        return { agentName, result }
      } catch (error: any) {
        return { agentName, result: '', error: error.message }
      }
    })
    
    const results = await Promise.allSettled(promises)
    
    return results.map((result, index) => {
      if (result.status === 'fulfilled') {
        return result.value
      } else {
        return { 
          agentName: agentPrompts[index].agentName, 
          result: '', 
          error: result.reason.message 
        }
      }
    })
  }

  /**
   * Obter status das execu√ß√µes
   */
  getExecutionStatus(): {
    total: number
    running: number
    completed: number
    failed: number
    rate_limited: number
  } {
    const executions = Array.from(this.executions.values())
    
    return {
      total: executions.length,
      running: executions.filter(e => e.status === 'running').length,
      completed: executions.filter(e => e.status === 'completed').length,
      failed: executions.filter(e => e.status === 'failed').length,
      rate_limited: 0 // Task tool n√£o tem rate limit da mesma forma
    }
  }

  /**
   * Cleanup: limpar execu√ß√µes
   */
  async cleanup(): Promise<void> {
    this.isShuttingDown = true
    console.log('üßπ Limpando execu√ß√µes do Task delegator...')
    this.executions.clear()
    console.log('‚úÖ Task delegator cleanup completado')
  }

  /**
   * Verificar se Task tool est√° dispon√≠vel
   */
  static async checkTaskToolAvailable(): Promise<boolean> {
    // No Claude Code, Task tool sempre est√° dispon√≠vel
    return true
  }
}

// Create singleton instance
export const taskDelegator = new TaskDelegator()