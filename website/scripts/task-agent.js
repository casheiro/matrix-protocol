#!/usr/bin/env node

/**
 * CLI Script: Task Agent
 * Integra√ß√£o com Task tool do Claude Code para execu√ß√£o por agents especializados
 */

import { readFileSync } from 'fs'
import { resolve } from 'path'
import { fileURLToPath } from 'url'
import { AGENTS } from './agent-context.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = resolve(__filename, '..')
const projectRoot = resolve(__dirname, '..')
const docsPath = resolve(projectRoot, 'docs/dynamic-navigation')

/**
 * Gera prompt especializado para Task tool baseado no agent e task
 */
function generateTaskPrompt(agentKey, taskId, context = {}) {
  const agent = AGENTS[agentKey]
  if (!agent) {
    throw new Error(`Agent '${agentKey}' n√£o encontrado`)
  }

  // Ler contexto do projeto
  const projectOverview = readProjectOverview()
  const taskDetails = getTaskDetails(taskId)
  
  const prompt = `
# ü§ñ **AGENT ESPECIALIZADO: ${agent.name.toUpperCase()}**

## **üë§ SEU PAPEL**
Voc√™ √© **${agent.name}**, especialista em **${agent.role}** no projeto de Navega√ß√£o Din√¢mica.

### **üéØ SUAS RESPONSABILIDADES**
${agent.responsibilities.map(r => `- ${r}`).join('\n')}

### **üõ†Ô∏è SUAS FERRAMENTAS MCP**
${agent.tools.map(t => `- ${t}`).join('\n')}

## **üìã TASK A EXECUTAR**
${taskDetails ? `
**ID**: ${taskId}
**T√≠tulo**: ${taskDetails.title || 'N/A'}
**Descri√ß√£o**: ${taskDetails.description || 'Consultar backlog para detalhes completos'}
**Entreg√°veis**: ${taskDetails.deliverables || 'Consultar BACKLOG_EXECUTABLE.md'}
**Ferramentas Espec√≠ficas**: ${taskDetails.tools || agent.tools.join(', ')}
**Dependencies**: ${taskDetails.dependencies || 'Verificar no backlog'}
` : `
**ID**: ${taskId}
**Status**: Consultar BACKLOG_EXECUTABLE.md para detalhes completos
**Localiza√ß√£o**: /docs/dynamic-navigation/BACKLOG_EXECUTABLE.md
`}

## **üéØ OBJETIVO PRINCIPAL**
${projectOverview.objective || 'Implementar navega√ß√£o din√¢mica que autodescobra estrutura do `/content` como no Docusaurus'}

## **üìö DOCUMENTA√á√ÉO DE REFER√äNCIA**
- **Contexto Completo**: /docs/dynamic-navigation/PROJECT_OVERVIEW.md
- **Backlog com Tasks**: /docs/dynamic-navigation/BACKLOG_EXECUTABLE.md  
- **Status do Projeto**: /docs/dynamic-navigation/EXECUTION_LOG.md
- **Sua Equipe**: /docs/dynamic-navigation/TEAM_AGENTS.md

## **üîÑ WORKFLOW DE EXECU√á√ÉO**
1. **Ler documenta√ß√£o** relevante usando Read tool
2. **Executar task** usando suas ferramentas MCP espec√≠ficas
3. **Atualizar progresso** ao final: \`node scripts/update-progress.js ${taskId} COMPLETED ${agentKey}\`
4. **Fazer handoff** se necess√°rio para pr√≥ximo agent

## **üí° CONTEXTO ADICIONAL**
${context.additionalInfo || 'Use suas ferramentas MCP para implementar a funcionalidade necess√°ria.'}

## **‚ö†Ô∏è IMPORTANTE**
- Mantenha foco no objetivo da navega√ß√£o din√¢mica
- Use apenas suas ferramentas MCP atribu√≠das
- Consulte documenta√ß√£o antes de implementar
- Registre progresso durante execu√ß√£o

---
**üöÄ Execute a task usando suas ferramentas especializadas!**
`

  return prompt
}

/**
 * L√™ overview do projeto
 */
function readProjectOverview() {
  try {
    const overviewPath = resolve(docsPath, 'PROJECT_OVERVIEW.md')
    const content = readFileSync(overviewPath, 'utf-8')
    
    // Parse b√°sico do objective
    const objectiveMatch = content.match(/## \*\*üéØ OBJETIVO DA SOLU√á√ÉO\*\*[\s\S]*?Substituir o sistema atual por uma \*\*navega√ß√£o completamente din√¢mica\*\* que:([\s\S]*?)(?=##|$)/i)
    
    return {
      objective: objectiveMatch ? 
        'Substituir navega√ß√£o hardcoded por sistema din√¢mico que autodescobra estrutura do /content' :
        'Implementar navega√ß√£o din√¢mica para o projeto'
    }
  } catch (error) {
    return {
      objective: 'Implementar navega√ß√£o din√¢mica que autodescobra estrutura do /content como no Docusaurus'
    }
  }
}

/**
 * Obt√©m detalhes da task do backlog
 */
function getTaskDetails(taskId) {
  try {
    const backlogPath = resolve(docsPath, 'BACKLOG_EXECUTABLE.md')
    const content = readFileSync(backlogPath, 'utf-8')
    
    // Parse da task espec√≠fica
    const taskRegex = new RegExp(`\\*\\*TASK ${taskId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}[^*]*\\*\\*([\\s\\S]*?)(?=\\*\\*TASK|##|$)`, 'i')
    const match = content.match(taskRegex)
    
    if (match) {
      const taskSection = match[1]
      
      // Extrair campos
      const titleMatch = taskSection.match(/\*\*T√≠tulo\*\*:\s*([^\n]*)/i)
      const responsavelMatch = taskSection.match(/\*\*Respons√°vel\*\*:\s*([^\n]*)/i) 
      const ferramentasMatch = taskSection.match(/\*\*Ferramentas\*\*:\s*([^\n]*)/i)
      const entregavelMatch = taskSection.match(/\*\*Entreg√°vel\*\*:\s*([^\n]*)/i)
      const dependenciasMatch = taskSection.match(/\*\*Depend√™ncias\*\*:\s*([^\n]*)/i)
      
      return {
        title: titleMatch ? titleMatch[1].trim() : null,
        responsible: responsavelMatch ? responsavelMatch[1].trim() : null,
        tools: ferramentasMatch ? ferramentasMatch[1].trim() : null,
        deliverables: entregavelMatch ? entregavelMatch[1].trim() : null,
        dependencies: dependenciasMatch ? dependenciasMatch[1].trim() : null
      }
    }
    
    return null
  } catch (error) {
    console.warn(`‚ö†Ô∏è N√£o foi poss√≠vel ler detalhes da task: ${error.message}`)
    return null
  }
}

/**
 * Gera configura√ß√£o para Task tool
 */
function generateTaskToolConfig(agentKey, taskId, context = {}) {
  const prompt = generateTaskPrompt(agentKey, taskId, context)
  
  return {
    subagent_type: "general-purpose",
    description: `${AGENTS[agentKey].name} executing ${taskId}`,
    prompt: prompt
  }
}

/**
 * Gera configura√ß√£o para agent espec√≠fico sem task
 */
function generateAgentConfig(agentKey, purpose = "contexto e pr√≥xima a√ß√£o") {
  const agent = AGENTS[agentKey]
  if (!agent) {
    throw new Error(`Agent '${agentKey}' n√£o encontrado`)
  }

  const prompt = `
# ü§ñ **CONTEXTO DO AGENT: ${agent.name.toUpperCase()}**

## **üë§ SEU PAPEL**
Voc√™ √© **${agent.name}**, especialista em **${agent.role}** no projeto de Navega√ß√£o Din√¢mica.

### **üéØ SUAS RESPONSABILIDADES**
${agent.responsibilities.map(r => `- ${r}`).join('\n')}

### **üõ†Ô∏è SUAS FERRAMENTAS MCP**
${agent.tools.map(t => `- ${t}`).join('\n')}

## **üìã INSTRU√á√ïES**
1. **Use Read tool** para consultar: \`/docs/dynamic-navigation/EXECUTION_LOG.md\`
2. **Identifique** sua pr√≥xima task dispon√≠vel
3. **Execute** \`node scripts/next-task.js ${agentKey}\` para ver detalhes
4. **Proceda** conforme orienta√ß√µes da pr√≥xima task

## **üéØ OBJETIVO PRINCIPAL**
Implementar navega√ß√£o din√¢mica que autodescobra estrutura do \`/content\` como no Docusaurus.

## **üìö DOCUMENTA√á√ÉO**
- **Status**: /docs/dynamic-navigation/EXECUTION_LOG.md
- **Backlog**: /docs/dynamic-navigation/BACKLOG_EXECUTABLE.md
- **Contexto**: /docs/dynamic-navigation/PROJECT_OVERVIEW.md

---
**‚ö° Comece verificando seu status atual e pr√≥xima task!**
`

  return {
    subagent_type: "general-purpose", 
    description: `${agent.name} agent context and next actions`,
    prompt: prompt
  }
}

/**
 * Lista configura√ß√µes dispon√≠veis para todos os agents
 */
function listAvailableConfigs() {
  const configs = []
  
  Object.entries(AGENTS).forEach(([key, agent]) => {
    configs.push({
      agentKey: key,
      agentName: agent.name,
      role: agent.role,
      tools: agent.tools,
      contextCommand: `node scripts/task-agent.js context ${key}`,
      taskCommand: `node scripts/task-agent.js task ${key} [TASK_ID]`
    })
  })
  
  return configs
}

/**
 * Formata output de help
 */
function formatHelpOutput() {
  const configs = listAvailableConfigs()
  
  return `
# ü§ñ **TASK AGENT - Integra√ß√£o com Task Tool**

## **üìã USO**
\`node scripts/task-agent.js <command> <agentKey> [taskId]\`

## **üîß COMANDOS**

### **context <agentKey>**
Gera configura√ß√£o para obter contexto do agent via Task tool
\`\`\`bash
node scripts/task-agent.js context ricardo
\`\`\`

### **task <agentKey> <taskId>**
Gera configura√ß√£o para executar task espec√≠fica via Task tool
\`\`\`bash
node scripts/task-agent.js task ricardo TASK_1.1.1
\`\`\`

### **json <command> <agentKey> [taskId]**
Output em formato JSON para integra√ß√£o direta
\`\`\`bash
node scripts/task-agent.js json task ricardo TASK_1.1.1
\`\`\`

## **üë• AGENTS DISPON√çVEIS**
${configs.map(config => `
### **${config.agentKey}** - ${config.agentName}
- **Role**: ${config.role}
- **Tools**: ${config.tools.join(', ')}
- **Context**: \`${config.contextCommand}\`
- **Task**: \`${config.taskCommand}\`
`).join('')}

## **üîó INTEGRA√á√ÉO COM CLAUDE CODE**

### **Passo 1**: Gerar configura√ß√£o
\`\`\`bash
node scripts/task-agent.js task ricardo TASK_1.1.1
\`\`\`

### **Passo 2**: Usar com Task tool
\`\`\`javascript
await Task({
  subagent_type: "general-purpose",
  description: "Ricardo executing TASK_1.1.1", 
  prompt: "[prompt gerado pelo script]"
})
\`\`\`

### **Passo 3**: Agent executa automaticamente
O Task tool invoca agent especializado com contexto completo.

---
**üí° Use este sistema para execu√ß√£o automatizada via Task tool do Claude Code!**
`
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2)
  
  if (args.length === 0 || args[0] === 'help' || args[0] === '--help') {
    console.log(formatHelpOutput())
    return
  }
  
  const [command, agentKey, taskId] = args
  const outputJson = command === 'json'
  const actualCommand = outputJson ? args[1] : command
  const actualAgentKey = outputJson ? args[2] : agentKey
  const actualTaskId = outputJson ? args[3] : taskId
  
  if (!actualAgentKey || !AGENTS[actualAgentKey.toLowerCase()]) {
    console.error(`‚ùå Agent '${actualAgentKey}' n√£o encontrado.`)
    console.log('üë• Agents dispon√≠veis: ' + Object.keys(AGENTS).join(', '))
    process.exit(1)
  }
  
  try {
    let config
    
    switch (actualCommand) {
      case 'context':
        config = generateAgentConfig(actualAgentKey.toLowerCase())
        break
        
      case 'task':
        if (!actualTaskId) {
          console.error('‚ùå Task ID necess√°rio para comando task')
          console.log('üí° Uso: node scripts/task-agent.js task <agentKey> <taskId>')
          process.exit(1)
        }
        config = generateTaskToolConfig(actualAgentKey.toLowerCase(), actualTaskId)
        break
        
      default:
        console.error(`‚ùå Comando inv√°lido: ${actualCommand}`)
        console.log('üìã Comandos v√°lidos: context, task, json')
        process.exit(1)
    }
    
    if (outputJson) {
      console.log(JSON.stringify(config, null, 2))
    } else {
      console.log('ü§ñ **CONFIGURA√á√ÉO PARA TASK TOOL**')
      console.log('='.repeat(50))
      console.log('')
      console.log('**Use com Task tool do Claude Code:**')
      console.log('')
      console.log('```javascript')
      console.log('await Task({')
      console.log(`  subagent_type: "${config.subagent_type}",`)
      console.log(`  description: "${config.description}",`)
      console.log(`  prompt: \`${config.prompt.slice(0, 100)}...\``)
      console.log('})')
      console.log('```')
      console.log('')
      console.log('**Prompt completo:**')
      console.log('```')
      console.log(config.prompt)
      console.log('```')
    }
    
  } catch (error) {
    console.error(`‚ùå ${error.message}`)
    process.exit(1)
  }
}

// Executar se script for chamado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  main()
}

export { generateTaskPrompt, generateTaskToolConfig, generateAgentConfig }