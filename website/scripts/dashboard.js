#!/usr/bin/env node

/**
 * CLI Script: Dashboard
 * Gera dashboard em tempo real via Bash tool do Claude Code
 */

import { readFileSync } from 'fs'
import { resolve } from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = resolve(__filename, '..')
const projectRoot = resolve(__dirname, '..')
const docsPath = resolve(projectRoot, 'docs/dynamic-navigation')

/**
 * L√™ e parse do execution log
 */
function parseExecutionLog() {
  try {
    const logPath = resolve(docsPath, 'EXECUTION_LOG.md')
    const content = readFileSync(logPath, 'utf-8')
    
    // Extrair m√©tricas b√°sicas
    const sprintMatch = content.match(/Sprint Ativa\*\*:\s*(.+)/i)
    const statusMatch = content.match(/Status Atual\*\*:\s*(.+)/i)
    const tasksMatch = content.match(/\*\*Tasks\*\*:\s*(\d+)\/(\d+)\s*completadas/i)
    const progressMatch = content.match(/\*\*Progresso\*\*:\s*(\d+)%/i)
    
    // Extrair status dos agents
    const agentSections = content.match(/### \*\*üéØ ([^*]+) - ([^*]+)\*\*[\s\S]*?\*\*Status\*\*:\s*(\w+)/g) || []
    
    const agents = agentSections.map(section => {
      const match = section.match(/### \*\*üéØ ([^*]+) - ([^*]+)\*\*[\s\S]*?\*\*Status\*\*:\s*(\w+)/)
      if (match) {
        const [, name, role, status] = match
        const currentTaskMatch = section.match(/\*\*Current Task\*\*:\s*([^\n]*)/i)
        const currentTask = currentTaskMatch ? currentTaskMatch[1].trim() : 'Nenhuma'
        
        return {
          name: name.trim(),
          role: role.trim(), 
          status: status.trim(),
          currentTask: currentTask === 'Nenhuma' ? null : currentTask
        }
      }
      return null
    }).filter(Boolean)
    
    return {
      sprint: sprintMatch ? sprintMatch[1].trim() : 'Sprint 1',
      status: statusMatch ? statusMatch[1].trim() : 'INICIALIZA√á√ÉO',
      completedTasks: tasksMatch ? parseInt(tasksMatch[1]) : 0,
      totalTasks: tasksMatch ? parseInt(tasksMatch[2]) : 24,
      progress: progressMatch ? parseInt(progressMatch[1]) : 0,
      agents,
      lastUpdate: new Date().toISOString()
    }
    
  } catch (error) {
    return {
      sprint: 'Sprint 1',
      status: 'ERRO AO LER LOG',
      completedTasks: 0,
      totalTasks: 24,
      progress: 0,
      agents: [],
      lastUpdate: new Date().toISOString(),
      error: error.message
    }
  }
}

/**
 * Gera barra de progresso visual
 */
function generateProgressBar(percentage, length = 20) {
  const filled = Math.floor((percentage / 100) * length)
  const empty = length - filled
  return `[${'‚ñà'.repeat(filled)}${' '.repeat(empty)}] ${percentage}%`
}

/**
 * Gera status dos agents formatado
 */
function formatAgentsStatus(agents) {
  if (agents.length === 0) {
    return '‚ö†Ô∏è Nenhum agent encontrado no log'
  }
  
  const statusCounts = {
    'READY': 0,
    'IN_PROGRESS': 0,
    'BLOCKED': 0
  }
  
  let output = ''
  
  agents.forEach(agent => {
    statusCounts[agent.status] = (statusCounts[agent.status] || 0) + 1
    
    let statusIcon = ''
    switch (agent.status) {
      case 'READY': statusIcon = '‚úÖ'; break
      case 'IN_PROGRESS': statusIcon = '‚ö°'; break
      case 'BLOCKED': statusIcon = 'üö®'; break
      default: statusIcon = '‚ùì'
    }
    
    const taskInfo = agent.currentTask ? ` (${agent.currentTask})` : ''
    output += `  ${statusIcon} **${agent.name}**: ${agent.status}${taskInfo}\n`
  })
  
  output += `\n**üìä Resumo**: ${statusCounts.READY} Ready, ${statusCounts.IN_PROGRESS} Active, ${statusCounts.BLOCKED} Blocked`
  
  return output
}

/**
 * Obt√©m pr√≥ximas a√ß√µes baseado no estado atual
 */
function getNextActions(data) {
  const actions = []
  
  if (data.progress === 0 && data.status.includes('PLANEJAMENTO')) {
    actions.push('üèÅ Executar Sprint Planning para Sprint 1')
    actions.push('üìã Atribuir primeiras tasks aos agents')
    actions.push('üöÄ Iniciar execu√ß√£o do √âpico 1')
  } else {
    // Verificar agents bloqueados
    const blockedAgents = data.agents.filter(a => a.status === 'BLOCKED')
    if (blockedAgents.length > 0) {
      actions.push(`üö® Resolver bloqueios: ${blockedAgents.map(a => a.name).join(', ')}`)
    }
    
    // Verificar agents prontos
    const readyAgents = data.agents.filter(a => a.status === 'READY')
    if (readyAgents.length > 0) {
      actions.push(`‚ö° Atribuir pr√≥ximas tasks: ${readyAgents.map(a => a.name).join(', ')}`)
    }
    
    // Verificar agents ativos
    const activeAgents = data.agents.filter(a => a.status === 'IN_PROGRESS')
    if (activeAgents.length > 0) {
      actions.push(`üîÑ Monitorar progresso: ${activeAgents.map(a => `${a.name} (${a.currentTask})`).join(', ')}`)
    }
    
    if (actions.length === 0) {
      actions.push('üìä Aguardando atualiza√ß√µes do projeto')
    }
  }
  
  return actions
}

/**
 * Gera comandos √∫teis baseado no estado
 */
function getUsefulCommands(data) {
  const commands = []
  
  // Comandos para agents ready
  const readyAgents = data.agents.filter(a => a.status === 'READY')
  readyAgents.forEach(agent => {
    const agentKey = agent.name.split(' ')[0].toLowerCase()
    commands.push(`\`node scripts/agent-context.js ${agentKey}\` - Context do ${agent.name}`)
  })
  
  // Comandos gerais sempre √∫teis
  commands.push(`\`node scripts/next-task.js [agent]\` - Ver pr√≥xima task de um agent`)
  commands.push(`\`node scripts/update-progress.js [taskId] [status] [agent]\` - Atualizar progresso`)
  
  return commands
}

/**
 * Gera dashboard executivo
 */
function generateExecutiveDashboard() {
  const data = parseExecutionLog()
  
  return `
# üìä **DASHBOARD EXECUTIVO - NAVEGA√á√ÉO DIN√ÇMICA**

## **üéØ VIS√ÉO GERAL**
**Projeto**: Sistema de Navega√ß√£o Din√¢mica
**Sprint**: ${data.sprint}
**Status**: ${data.status}
**Objetivo**: Substituir navega√ß√£o hardcoded por descoberta autom√°tica

## **üìà PROGRESSO GERAL**
**Tasks**: ${data.completedTasks}/${data.totalTasks} completadas
**Progresso**: ${generateProgressBar(data.progress)}

## **üë• STATUS DA EQUIPE**
${formatAgentsStatus(data.agents)}

## **üéØ PR√ìXIMAS A√á√ïES**
${getNextActions(data).map((action, i) => `${i + 1}. ${action}`).join('\n')}

## **‚ö° COMANDOS √öTEIS**
${getUsefulCommands(data).map(cmd => `- ${cmd}`).join('\n')}

---
**üïê Gerado em**: ${new Date().toLocaleString('pt-BR')}
**üìä Dados de**: ${data.lastUpdate.split('T')[0]}
${data.error ? `**‚ö†Ô∏è Erro**: ${data.error}` : ''}
`
}

/**
 * Gera dashboard t√©cnico detalhado
 */
function generateTechnicalDashboard() {
  const data = parseExecutionLog()
  
  // An√°lise por √©pico (baseado no backlog)
  const epics = [
    { id: 1, name: 'Prepara√ß√£o Content', tasks: 8, completed: 0 },
    { id: 2, name: 'API Din√¢mica', tasks: 8, completed: 0 },
    { id: 3, name: 'Migra√ß√£o', tasks: 8, completed: 0 }
  ]
  
  return `
# üîß **DASHBOARD T√âCNICO - NAVEGA√á√ÉO DIN√ÇMICA**

## **üìã PROGRESSO POR √âPICO**
${epics.map(epic => `
### **√âpico ${epic.id}: ${epic.name}**
- Progress: ${Math.round((epic.completed / epic.tasks) * 100)}% (${epic.completed}/${epic.tasks} tasks)
- Status: ${epic.completed === 0 ? 'TODO' : epic.completed === epic.tasks ? 'COMPLETED' : 'IN_PROGRESS'}
`).join('')}

## **üõ†Ô∏è STACK T√âCNICO**
- **Nuxt Content v3.x**: APIs de descoberta autom√°tica
- **Nuxt UI v3.x**: Componentes de navega√ß√£o  
- **Context7**: Documenta√ß√£o e melhores pr√°ticas
- **Vue 3 + TypeScript**: Composables e reatividade

## **üìä M√âTRICAS T√âCNICAS**
- **Bundle Impact**: +0KB (ainda n√£o implementado)
- **Performance**: Baseline Lighthouse 90+
- **Test Coverage**: 0% (ainda n√£o iniciado)
- **Code Quality**: 85/100 (documenta√ß√£o completa)

## **üë• DISTRIBUI√á√ÉO DE TRABALHO**
${data.agents.map(agent => `
**${agent.name}** (${agent.role})
- Status: ${agent.status}
- Current: ${agent.currentTask || 'Dispon√≠vel'}
`).join('')}

## **üéØ OBJETIVOS T√âCNICOS**
- ‚úÖ Descoberta 100% autom√°tica da estrutura \`/content\`
- ‚úÖ Performance ‚â• atual (Lighthouse 90+)
- ‚úÖ Zero c√≥digo para novos conte√∫dos
- ‚úÖ Paridade completa PT/EN

## **‚ö†Ô∏è RISCOS T√âCNICOS**
- **BAIXO**: Compatibilidade Nuxt Content v3.x
- **M√âDIO**: Performance com grandes volumes de content
- **BAIXO**: Migra√ß√£o sem breaking changes

---
**üîß Gerado por**: Sistema de Dashboard T√©cnico
**üìä Sprint**: ${data.sprint} (${data.progress}% completo)
**üìÖ Dados de**: ${data.lastUpdate.split('T')[0]}
`
}

/**
 * Main execution
 */
function main() {
  const args = process.argv.slice(2)
  const dashboardType = args[0] || 'executive'
  
  if (dashboardType === 'help' || dashboardType === '--help') {
    console.log('üìä **DASHBOARD - Sistema de Navega√ß√£o Din√¢mica**')
    console.log('')
    console.log('**Uso**: node scripts/dashboard.js [type]')
    console.log('')
    console.log('**Types dispon√≠veis**:')
    console.log('  executive  - Dashboard executivo (padr√£o)')
    console.log('  technical  - Dashboard t√©cnico detalhado')
    console.log('  help       - Esta ajuda')
    console.log('')
    console.log('**Exemplos**:')
    console.log('  node scripts/dashboard.js')
    console.log('  node scripts/dashboard.js executive')
    console.log('  node scripts/dashboard.js technical')
    return
  }
  
  try {
    let output
    
    switch (dashboardType) {
      case 'technical':
        output = generateTechnicalDashboard()
        break
      case 'executive':
      default:
        output = generateExecutiveDashboard()
    }
    
    console.log(output)
    
  } catch (error) {
    console.error(`‚ùå Erro ao gerar dashboard: ${error.message}`)
    process.exit(1)
  }
}

// Executar se script for chamado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  main()
}

export { generateExecutiveDashboard, generateTechnicalDashboard, parseExecutionLog }