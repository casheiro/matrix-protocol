flow_id: zof-jwt-implementation-202401
flow_name: Implementação de Padrão de Autenticação
triggered_by: work.proposed
trigger_context: Necessidade de implementar autenticação segura na API do produto
team_context: Squad Backend - API Core
timestamp_start: "2024-01-15 09:00:00"
timestamp_end: "2024-01-15 16:30:00"

# Vínculo inicial ao Oráculo
oracle_context:
  motivating_ukis:
    - unik-technical-jwt-authentication-pattern
    - unik-business-security-requirements
    - unik-culture-code-review-process
    - unik-technical-api-error-handling

# Fluxo de Estados
flow_execution:

  # Estado 1: INTAKE
  - state: intake
    timestamp: "2024-01-15 09:00:00"
    signals:
      context: "Recebida história: Como usuário, quero me autenticar na API para acessar recursos protegidos"
      decision: "Validada necessidade de implementar autenticação baseado em requisitos de segurança"
      result: "Contexto estruturado: implementar solução de autenticação com renovação"
    actions_taken:
      - Capturada história de usuário da sprint planning
      - Validados critérios de aceitação
      - Identificados requisitos não-funcionais de segurança
    next_state: understand

  # Estado 2: UNDERSTAND  
  - state: understand
    timestamp: "2024-01-15 09:30:00"
    oracle_ukis_consulted:
      - unik-technical-jwt-authentication-pattern
      - unik-business-security-requirements
      - unik-technical-token-expiration-policy
    signals:
      context: "Consultados padrões de autenticação e políticas de segurança no Oráculo"
      decision: "Identificado padrão Bearer Token com renovação, expiração conforme política de negócio"
      result: "Estratégia: Token de acesso + Token de renovação com middleware de validação"
    oracle_guidance:
      security_requirements: "Tokens devem expirar conforme política de negócio"
      authentication_pattern: "Usar Bearer Token no header de autorização"
      error_handling: "Retornar códigos apropriados para tokens inválidos ou recursos não autorizados"
    next_state: decide

  # Estado 3: DECIDE
  - state: decide  
    timestamp: "2024-01-15 10:00:00"
    reasoning_ukis:
      - unik-technical-jwt-authentication-pattern
      - unik-business-vendor-approval-policy
    signals:
      context: "Avaliadas opções de implementação baseadas em diretrizes do Oráculo"
      decision: "Escolhida abordagem aprovada pela política de vendors com middleware customizado"
      result: "Plano definido: implementar serviço de autenticação + middleware + endpoints"
    decision_rationale: |
      Abordagem escolhida por:
      - Está na lista de padrões aprovados pela política organizacional
      - Suporta algoritmos conforme padrão de segurança
      - Tem suporte ativo e boa documentação
      - Integra bem com nossa arquitetura atual
    implementation_plan:
      - Criar serviço de autenticação para geração/validação
      - Implementar middleware de autenticação
      - Criar endpoints de entrada e renovação
      - Adicionar testes unitários e integração
    next_state: act

  # Estado 4: ACT
  - state: act
    timestamp: "2024-01-15 10:30:00"
    signals:
      context: "Iniciada implementação da solução de autenticação"
      decision: "Executada implementação seguindo padrões da cultura da equipe"
      result: "Solução implementada conforme padrão definido pelo Oráculo"
    conceptual_execution:
      approach_taken: "Implementação guiada por UKIs do Oráculo"
      team_practices_applied: "Seguidos padrões de qualidade da equipe"
      knowledge_validation: "Solução validada contra diretrizes do Oráculo"
    next_state: review

  # Estado 5: REVIEW (Opcional)
  - state: review
    timestamp: "2024-01-15 14:00:00"
    signals:
      context: "Submetida solução para validação conforme processo da equipe"
      decision: "Aprovado após ajustes baseados em UKIs do Oráculo"
      result: "Solução validada e refinada conforme diretrizes"
    conceptual_validation:
      oracle_ukis_applied:
        - unik-culture-code-review-process
        - unik-technical-api-error-handling
      knowledge_refinements:
        - Aplicadas melhorias baseadas em padrões do Oráculo
        - Documentação alinhada com diretrizes existentes
        - Solução validada contra conhecimento estabelecido
      validation_outcome: "Conforme padrões ZOF"
    next_state: enrich

  # Estado 6: EVALUATE FOR ENRICH
  - state: evaluate_for_enrich
    timestamp: "2024-01-15T15:30:00Z"
    signals:
      context: "Avaliando critérios MOC para enriquecimento"
      decision: "Conhecimento aprovado para enriquecimento com escopo 'team'"
      result: "Autorizado para criar UKIs no escopo permitido"
    next_state: enrich

  # Estado 7: ENRICH (Obrigatório)
  - state: enrich
    timestamp: "2024-01-15 16:00:00"
    signals:
      context: "Implementação de autenticação concluída com sucesso, aprendizados capturados"
      decision: "Documentar implementação como exemplo reutilizável e atualizar padrão existente"
      result: "Criados 2 UKIs: exemplo de implementação + refinamento do padrão"
    new_ukis_created:
      - id: uki:technical:example:jwt-implementation
        scope_ref: team
        scope_mode: restricted
        domain_ref: technical
        type_ref: example
        context_ref: implementation
        maturity_ref: validated
        status: active
        version: "1.0.0"
        created_date: "2024-01-15"
        last_modified: "2024-01-15"
         title: "Exemplo de Implementação de Autenticação Baseada em Token"
        content: |
          Implementação de padrão de autenticação seguindo diretrizes do Oráculo.
          
          Componentes conceituais:
          - Serviço de tokens: geração e validação
          - Middleware de autenticação: interceptação de requisições
          - Endpoints de autenticação: entrada e renovação
          
          Diretrizes de segurança aplicadas:
          - Tokens com expiração conforme política de negócio
          - Tokens de renovação com ciclo de vida controlado
          - Algoritmos seguindo padrões de segurança estabelecidos
          - Configurações alinhadas com requisitos organizacionais
          
          Aplicação do padrão:
          - Implementação da arquitetura definida pelo Oráculo
          - Validação contra diretrizes de segurança existentes
          - Processo de autenticação padronizado
        examples:
          - input: "Usuário faz login com credenciais válidas"
            output: "Retorna token de acesso + token de renovação"
          - input: "Requisição com token expirado"
            output: "Resposta apropriada com orientação para renovação"
          - input: "Solicitação de renovação com token válido"
            output: "Novo token de acesso gerado mantendo token de renovação"
        related_to:
          - target: unik-technical-jwt-authentication-pattern
            relation_type: derives_from
            description: Derivada do padrão técnico de autenticação JWT
          - target: unik-business-security-requirements
            relation_type: implements
            description: Implementa requisitos de segurança do negócio
          - target: unik-technical-api-error-handling
            relation_type: relates_to
            description: Relaciona-se com padrões de tratamento de erros
        intent_of_use:
          - generate_code
          - understand_implementation
          - standardize_process
        use_case_stage:
          - implementation
          - peer_review
          - documentation
        last_validation: "2024-01-15"

      - id: uki:technical:pattern:token-refresh
        scope_ref: team
        scope_mode: propagated
        domain_ref: technical
        type_ref: pattern
        context_ref: implementation
        maturity_ref: validated
        status: active
        version: "1.0.0"
        created_date: "2024-01-15"
        last_modified: "2024-01-15"
         title: "Padrão de Renovação de Token com Armazenamento Seguro"
        content: |
          Padrão para implementar renovação de tokens usando armazenamento seguro.
          
          Características:
          - Tokens de renovação armazenados de forma segura
          - Chaves estruturadas para identificação única
          - TTL automático para expiração
          - Suporte a revogação manual
          
          Implementação conceitual:
          1. Ao fazer login, gerar token de renovação único
          2. Armazenar de forma segura com TTL apropriado
          3. Na renovação, validar existência e renovar token de acesso
          4. Rotacionar token de renovação periodicamente
          
          Benefícios:
          - Performance superior ao armazenamento convencional
          - TTL automático evita limpeza manual
          - Escalabilidade horizontal
        examples:
          - input: "Login de usuário"
            output: "Armazenamento seguro do token de renovação com TTL"
          - input: "Solicitação de renovação"
            output: "Validação e geração de novo token de acesso"
          - input: "Logout"
            output: "Token de renovação invalidado"
        related_to:
          - target: unik-technical-jwt-authentication-pattern
            relation_type: extends
            description: Estende o padrão com exemplo de melhoria
          - target: unik-technical-authentication-implementation-example
            relation_type: replaces
            description: Substitui implementação anterior com melhorias
        intent_of_use:
          - standardize_process
          - improve_performance
          - ensure_security
        use_case_stage:
          - implementation
          - design
        last_validation: "2024-01-15"

# Métricas de Telemetria
telemetry:
  workflow_id: "zof-jwt-implementation-202401"
  execution_start: "2024-01-15T09:00:00Z"
  execution_end: "2024-01-15T16:30:00Z"
  total_duration_seconds: 27000
  
  state_transition_duration:
    intake_to_understand:
      timestamp_start: "2024-01-15T09:00:00Z"
      timestamp_end: "2024-01-15T09:30:00Z"
      duration_seconds: 1800
    understand_to_decide:
      timestamp_start: "2024-01-15T09:30:00Z"
      timestamp_end: "2024-01-15T10:00:00Z"
      duration_seconds: 1800
    decide_to_act:
      timestamp_start: "2024-01-15T10:00:00Z"
      timestamp_end: "2024-01-15T10:30:00Z"
      duration_seconds: 1800
    act_to_review:
      timestamp_start: "2024-01-15T10:30:00Z"
      timestamp_end: "2024-01-15T14:00:00Z"
      duration_seconds: 12600
    review_to_enrich:
      timestamp_start: "2024-01-15T14:00:00Z"
      timestamp_end: "2024-01-15T16:00:00Z"
      duration_seconds: 7200
    enrich_duration:
      timestamp_start: "2024-01-15T16:00:00Z"
      timestamp_end: "2024-01-15T16:30:00Z"
      duration_seconds: 1800

  transition_quality_score:
    overall_workflow_score: 92
    state_scores:
      intake: 95        # Captura completa de requisitos
      understand: 90    # Consulta abrangente ao Oráculo
      decide: 88        # Decisões bem fundamentadas
      act: 94           # Implementação eficaz
      review: 96        # Validação rigorosa
      enrich: 89        # UKIs de qualidade
    quality_factors:
      oracle_coverage: 94       # 100% decisões fundamentadas em UKIs
      explainability_depth: 92  # Sinais detalhados
      relationship_clarity: 85  # Clareza dos related_to

  workflow_health_metrics:
    completion_status: "successful"
    error_count: 0
    warning_count: 1
    retry_count: 0
    state_coverage:
      total_states: 6
      executed_states: 6
      skipped_states: 0
    oracle_availability: "available"
    enrichment_success: true

  oracle_enrichment_metrics:
    ukis_consulted: 5
    ukis_created: 2
    ukis_updated: 0
    relationship_count: 6
    knowledge_domains_touched:
      - technical
      - business
      - culture
    semantic_coherence_score: 88
    reusability_potential: "high"

  performance_indicators:
    throughput_score: 87          # Velocidade vs. qualidade
    efficiency_ratio: 0.78        # Tempo útil / tempo total
    oracle_hit_rate: 1.0          # UKIs encontrados / UKIs buscados
    decision_confidence: 0.91     # Confiança nas decisões tomadas

  observability_tags:
    team: "backend-squad"
    trigger_type: "work.proposed"
    complexity_level: "medium"
    ai_assistance_level: "high"
    feature_type: "authentication"
    business_criticality: "high"

# Reflexão Conceitual do Fluxo
flow_reflection:
  conceptual_completeness: "Todos os estados canônicos foram percorridos"
  oracle_integration: "Decisões fundamentadas em UKIs existentes"
  knowledge_enrichment: "Conhecimento devolvido ao Oráculo como especificado"
  explainability_maintained: "Sinais de contexto, decisão e resultado registrados"

# Aprendizados Conceituais
flow_learnings:
  - "Consultar Oráculo antes de decidir tecnologia evita retrabalho"
  - "Documentar implementação durante execução facilita enriquecimento"
  - "Processo de review opcional útil para conhecimento crítico"
  - "Relacionamentos entre UKIs essenciais para rastreabilidade"

# Conformidade ZOF
zof_compliance:
  - "✅ Fluxo iniciado por evento canônico (work.proposed)"
  - "✅ Consultou Oráculo para fundamentar decisões"
  - "✅ Registrou sinais de explicabilidade em cada estado"
  - "✅ Enriqueceu Oráculo com UKIs relacionadas"
  - "✅ Manteve rastreabilidade conceitual do processo"

# Fluxos Relacionados
related_flows:
  - zof-api-deployment-202401  # Próximo fluxo: deploy da API
  - zof-frontend-auth-integration-202401  # Fluxo paralelo: integração frontend